var store = [{
        "title": "Welcome to Jekyll!",
        "excerpt":"You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.   Jekyll requires blog post files to be named according to the following format:   YEAR-MONTH-DAY-title.MARKUP   Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.   Jekyll also offers powerful support for code snippets:   def print_hi(name)   puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT.  Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.   ","categories": [],
        "tags": [],
        "url": "/welcome-to-jekyll/",
        "teaser": null
      },{
        "title": "Redis",
        "excerpt":"Redis 特性  参考：https://www.cnblogs.com/kismetv/p/9853040.html, 它的实现原理和一些解决方案非常值得学习   持久化  分类     RDB   AOF   原理     参考：https://www.cnblogs.com/kismetv/p/9853040.html   主从复制     一主多从   读写分离   哨兵：高可用     需要独立的哨兵进程，哨兵进程会监控 Redis master 和 slave 进程   故障转移，自动实现主从切换   监控，负责监控 Redis master 和 slave 进程是否正常工作   集群：分布式  ","categories": ["database"],
        "tags": ["redis","cache"],
        "url": "/database/redis/",
        "teaser": null
      },{
        "title": "Linux",
        "excerpt":"登录  SSH 帐号和密码   SSH 帐号和公钥  ssh-keygen # 一路回车，生成 id_rsa 和 id_rsa.pub，也可以输入passphrase，来保护 key, 每次使用 key 时都需要输入 passphrase # 将 id_rsa.pub 的内容添加到 ~/.ssh/authorized_keys 中 cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys # 将 id_rsa 拉到本地，供 xshell 使用 ssh 远程到服务器时使用   常用命令  查看命令   进入 root  sudo -i   查看系统信息  uname -a  查看用户信息  whoami id grissom # 查看 grissom 用户  查看系统版本  cat /etc/issue # 查看系统版本 cat /proc/version # 查看内核版本  查看当前目录  pwd  查看当前目录下的文件  ls # 包括隐藏文件 ls -a # 包括隐藏文件，包括文件的详细信息 ls -al  ls -lh # 查看文件大小,人性化显示  查看端口占用情况  # 查看所有端口占用情况 netstat -anp # 查看所有端口占用情况，只显示监听端口 netstat -anp | grep LISTEN # 查看指定端口占用情况 lsof -i:8080   ss -anp | grep 8080  ss -tunlp | grep 8080   查看进程  ps -e # 查看所有进程 ps -ef # 查看zookeeper进程 ps -ef |grep zookeeper  # 显示cpu,内存,启动时间,命令行,并按内存使用量倒序排序 ps -aux --sort=-%mem top #实时查看进程, shift+m 按内存排序  查看日志  # 查看最后10行日志 tail -n 10 /var/log/messages # 查看最后10行日志，实时刷新 tail -f -n 10 /var/log/messages # 查看前面10行日志 head -n 10 /var/log/messages  查看文件  # 查看文件内容 cat /var/log/messages # 查看文件内容，实时刷新 tail -f /var/log/messages  查看文件大小  # 查看文件大小 du -sh /var/log/messages # 查看文件夹大小 du -sh /var/log dh -h /var/log dh -h --max-depth=1 # 查看当前目录下的文件夹大小,深度为1  wc [-lmw] [file] # 统计文件的行数、字数、字节数 ls |wc -l # 统计当前目录下的文件个数  查看磁盘使用情况  # 查看磁盘使用情况 df -h  查看内存使用量  # 查看内存使用量 free -m  查看系统负载  # 查看系统负载 uptime  查看系统时间  # 查看系统时间 date  查看系统环境变量  # 查看系统环境变量 env  查看防火墙状态  # 查看防火墙状态 systemctl status firewalld # 查看防火墙开放的端口 firewall-cmd --list-ports # 查看防火墙开放的服务 firewall-cmd --list-services  # 查看 ubuntu 防火墙状态 systemctl status ufw # 查看 ubuntu 防火墙开放的端口 ufw status # 查看 ubuntu 防火墙开放的服务 ufw status numbered  # 云服务器不需要防火墙,通过安全组来控制端口  查看命令  # 查看命令所在位置 which java whereis java # 查看命令所在位置，包括源码位置，以及配置文件位置 # 查看命令的帮助信息 man java   查看ip  # 查看ip ifconfig # 查看ip，只显示ip ifconfig | grep inet | grep -v inet6 | awk '{print $2}'   查看日志  # 查看日志 journalctl -u nginx.service   操作命令  用户和用户组管理  # 修改用户密码 passwd grissom # 修改系统时间 date -s \"2020-01-01 00:00:00\" # 修改系统时区 timedatectl set-timezone Asia/Shanghai # 修改系统语言 localectl set-locale LANG=zh_CN.UTF-8 # 修改系统主机名 hostnamectl set-hostname grissom # 添加用户 useradd grissom # 修改用户密码 passwd grissom # 添加用户到 sudo 组 usermod -aG sudo grissom # 添加用户到 root 组 usermod -aG root grissom # 删除用户 userdel grissom # 添加用户组 groupadd g1 # 删除用户组 groupdel g1 # 添加用户到用户组 usermod -aG g1 grissom # 删除用户从用户组 gpasswd -d grissom g1 # 查看用户组 cat /etc/group # 查看用户 cat /etc/passwd # 查看用户所在组 cat /etc/group | grep grissom   创建、删除、修改文件夹  # 创建文件夹 mkdir -p ./data/{dir1,dir2} # 删除文件夹 rm -rf ./data/{dir1,dir2} # 复制文件夹, -r 递归复制，-f 强制覆盖 cp -r ./data/{dir1,dir2} ./data/{dir1.bak,dir2.bak} # 修改文件权限,4r,2w,1x, 下面命令 owner 分rwx,group 分rx,other 分r chmod -R 777 ./data/{dir1,dir2} chmod +x sth.sh # 给文件添加可执行权限 chmod ug-x sth.sh # 给文件删除用户和组的可执行权限 # 修改文件所有者，grissom 是用户名，groupname 是用户组名, 如果用户组不存在，则会创建用户组,也可以不指定用户组 chown -R grissom:grissom ./data/{dir1,dir2} # 修改文件夹所有者和权限 chown -R grissom:grissom ./data/{dir1,dir2} &amp;&amp; chmod -R 777 ./data/{dir1,dir2} # 文件夹重命名 mv ./data/logs ./data/logs.bak  创建、删除、修改文件  # 创建文件 touch ./data/logs/test.log # 写入文件内容，如果文件不存在，则创建文件，如果文件存在，则追加内容, &gt;&gt; 表示追加，&gt; 表示覆盖 echo \"hello world\" &gt;&gt; ./data/logs/test.log # 删除文件 rm -rf ./data/logs/test.log # 复制文件夹, -r 递归复制，-f 强制覆盖 cp -r ./data/test1/{txt1.txt,txt2.txt} ./data/test2 # 修改文件权限,4r,2w,1x, 下面命令 owner 分rwx,group 分rx,other 分r chmod 754 ./data/logs/test.log # 修改文件所有者，grissom 是用户名，groupname 是用户组名, 如果用户组不存在，则会创建用户组,也可以不指定用户组 chown grissom:groupname ./data/logs/test.log # 修改文件所有者和权限 chown grissom:groupname ./data/logs/test.log &amp;&amp; chmod 777 ./data/logs/test.log # 文件重命名 mv ./data/logs/test.log ./data/logs/test.bak   批量操作  # 批量创建文件夹 mkdir -p ./data/{dir1,dir2} # 批量删除文件夹 rm -rf ./data/{dir1,dir2} # 批量复制文件夹, -r 递归复制，-f 强制覆盖 cp -r ./data/{dir1,dir2} ./data/{dir1.bak,dir2.bak} # 批量修改文件权限,4r,2w,1x, 下面命令 owner 分rwx,group 分rx,other 分r chmod -R 777 ./data/{dir1,dir2} # 批量执行 shell 文件 find ./data -name \"*.sh\" | xargs -I {} sh {} for file in $(ls ./data/*.sh); do sh $file; done    linux 常识  linux 文件系统  文件系统是一种数据结构，用于组织、管理和存储数据  linux 哲学  do one thing and do it well, 一个程序只做一件事，做好这件事  常见的配置文件和位置  # /etc/passwd 用户信息，不要直接修改，使用 useradd usermod userdel 等命令来修改 # /etc/shadow 用户密码,不要直接修改，使用 passwd 命令来修改 # /etc/group 用户组信息,不要直接修改，使用 groupadd groupdel 等命令来修改 # /etc/hosts 主机名和ip映射，可以直接修改 # /etc/hostname 主机名，可以直接修改 # /etc/profile 系统环境变量,使用 source /etc/profile 命令来生效 # /etc/my.cnf mysql 配置文件 # /etc/nginx/nginx.conf nginx 配置文件 # /etc/nginx/conf.d/ nginx 配置文件目录 # ~/.bashrc 用户环境变量,使用 source ~/.bashrc 命令来生效 # ~/.bash_profile 用户环境变量,使用 source ~/.bash_profile 命令来生效 # ~/.vimrc vim 配置文件 # ~/.gitconfig git 配置文件 # ~/.ssh/authorized_keys ssh 公钥 # ~/.ssh/id_rsa ssh 私钥 # ~/.ssh/id_rsa.pub ssh 公钥  linux 常用目录  # /bin 常用命令 # /sbin 系统管理命令 # /etc 配置文件 # /home 用户目录 # /root root 用户目录 # /usr/bin 用户命令 # /usr/sbin 用户系统管理命令 # /usr/local/bin 用户安装的命令 # /var/log 日志目录 # /var/lib/mysql mysql 数据目录 # /var/lib/nginx nginx 数据目录 # /mnt 挂载目录 # /tmp 临时目录 # /proc 进程目录 # /dev 设备目录 # /sys 系统目录   ","categories": ["os"],
        "tags": ["linux","server"],
        "url": "/os/linux/",
        "teaser": null
      },{
        "title": "SSL SSH Login",
        "excerpt":"申请免费的ssl证书  国内的阿里云、腾讯云、百度云等  都有免费的ssl证书，最长有效期1年，但是需要备案，备案需要花钱和实名制，所以这里不推荐使用。  国外的letsencrypt  可以申请免费的ssl证书，有效期3个月，但是可以自动续期，所以这里推荐使用。  需要安装certbot，将nginx.cnf交给她管理，到期后自动续期。  也可以手动生成证书，但是需要手动续期。  cloudflare  可申请 15 年有效期的免费 ssl 证书，但需要开启 cloudflare 的代理，它的代理免费，也有收费CDN。  freessl.cn  可申请 1 年有效期的免费 ssl 证书，不用备案但需要实名制。  freessl.org  可生成 90 天有效期的免费 ssl 证书，不用备案也不用实名制。  openssl 工具  生成自签名证书，不用备案也不用实名制，但是浏览器会提示不安全。小批量客户使用，可以手动导入CA证书到windows系统，避免提示不安全。   github  配置代理  修改 .gitconfig 文件，添加如下内容：  [http]     proxy = http://127.0.0.1:1080  1080 是你的 http 代理端口，如果是 socks5 代理，修改为：  [http]     proxy = socks5://127.0.0.1:1080  1080 是你的 socks5 代理端口。   除非你的代理是全局代理，否则需要配置 git 使用代理，否则 git 会直接访问 github，导致无法访问。  而浏览器之所以可以访问 github，是因为浏览器会自动使用系统代理，所以不需要手动配置。   登录方式  使用 personal access token 登录  推荐使用 https， 因为它可以绕过防火墙。参考https://github.com/settings/tokens。  windows credential manager 会保存密码，不用每次都输入密码。如果要删除登录，删除 credential manager 中的 github.com 的密码即可。也可以登录github.com 删除 personal access token。  SSH  使用 ssh 登录，需要先生成 ssh key，然后将公钥添加到 github.com 的 ssh key 中，参考https://github.com/settings/keys。   ","categories": ["security"],
        "tags": ["ssh","ssl","login"],
        "url": "/security/ssl-ssh-login/",
        "teaser": null
      },{
        "title": "科学上网",
        "excerpt":"OpenVPN  安装  服务端     参考 https://github.com/angristan/openvpn-install   全部默认即可   vpn 会安装虚拟网卡接管全部流量，如果不需要全部走vpn, 需要配置route, 可以在客户端也可以在服务端配置,但最终连上服务端时，服务端会把 push “route ip mask “ 这些配置发送给客户端配置文件起效, 同时需要注释掉配置文件里的 push \"redirect_gateway def1 bypass-dhcp\"   防火墙需要开放 1194/udp, 1194/tcp     客户端       建议使用最新版的 OpenVPN GUI   安装后在网络适配器里会多出 OpenVPN Data Channel Offload， 旧版本(2.4)多出 本地连接2, 而且默认都有红叉(Network cable unplugged)，需要等连上服务端后才会变为可用   配置文件需要去掉 setenv opt block-outside-dns， 否则会导致未走 vpn 的流量全部被block掉，而无法访问网络   配置route route 10.0.0.0 255.255.255.0 vpn_gateway, 所有 10.*开头的ip都会走 vpn gateway, 该配置可以直接写死在客户端配置文件，也可以写在服务端 push \"route 10.0.0.0 255.255.255.0 vpn_gateway\"   客户端会先将域名解析成 ip 后，才会走 vpn, 所以通过 vpn 的http 请求已是通过 DNS 解析后的 ip, vpn 只是服务器和客户端之间的一条流量通道，它不是代理，它和 shadowsocks, v2ray 这些代理有本质区别，这些代理是直接代理所请求url的服务器，vpn 查看浏览器的 remote-ip url原服务器的ip, 但代理的是代理的ip，一般是 127.0.0.1, 它们共同点都是加密通信，访问网络最终由服务器端的网络负责。   代理  shadowsocks  服务端     参考 https://github.com/shadowsocks/go-shadowsocks2   v2ray 插件https://github.com/shadowsocks/v2ray-plugin   生成自验证的ssl证书    # 生成CA根证书(用来签发服务器证书，供客户端验证证书是否可信) openssl genrsa -out ca.key 2048 openssl req -new -x509 -days 365 -key ca.key -subj \"/C=CN/ST=GD/L=SZ/O=Acme, Inc./CN=Acme Root CA\" -out ca.crt  # 签发证书，-subj 参数添加example.com域名, 强制客户端必须携带example.com域名的参数才能连接，用来伪装成正常网站的https访问 openssl req -newkey rsa:2048 -nodes -keyout server.key -subj \"/C=CN/ST=GD/L=SZ/O=Acme, Inc./CN=*.example.com\" -out server.csr openssl x509 -req -extfile &lt;(printf \"subjectAltName=DNS:example.com,DNS:www.example.com\") -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt  # 注意： ca.crt 需要发送给客户端(windows 系统则导入到 certmgr的Trusted Root Certification，以便让系统信任有该CA签发的证书。而 server.crt server.key 需要发送给服务端，server.key 是私钥，server.crt 是公钥，服务端需要用私钥解密客户端发送的数据，它不需要我们手动发送给客户端，因为客户端在连接上服务端后，服务端会发送 server.crt 给客户端，客户端会使用 ca.crt 验证 server.crt 是否可信，如果可信则会使用 server.crt 的公钥加密数据发送给服务端，服务端使用 server.key 解密数据，这样就实现了双向加密通信。       运行脚本   #/bin/sh ./shadowsocks2-linux -s 'ss://AEAD_CHACHA20_POLY1305:yourpassword@:443' -verbose     -plugin ./v2ray-plugin_linux_amd64 -plugin-opts \"server;tls;host=example.com;cert=./cert/server.crt;key=./cert/server.key\" &amp;  # -s 参数是加密方式和密码，-plugin 是插件，-plugin-opts 是插件参数，server 表示服务端，tls 表示使用 tls 加密，host 是域名，cert 是证书，key 是私钥   客户端     参考 https://github.com/shadowsocks/shadowsocks-windows   v2ray 插件https://github.com/shadowsocks/v2ray-plugin   配置   {   \"configs\": [     {       \"server\": \"yourserverip\",       \"server_port\": 443,       \"password\": \"yourpassword\",       \"method\": \"chacha20-ietf-poly1305\",       \"plugin\": \"C:\\\\v2ray\\\\v2ray-plugin_windows_amd64.exe\",       \"plugin_opts\": \"tls;host=example.com\",//ca.crt 提前导入到 windows 系统的受信任的根证书颁发机构，这里就不用配置 cert 了       // \"plugin_opts\": \"tls;host=example.com;cert=./cert/ca.crt\",        \"plugin_args\": \"\",       \"remarks\": \"\",       \"timeout\": 5     }   ], }   v2ray  服务端     参考 x-ui https://github.com/vaxilu/x-ui/   命令 bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh)   安装(支持docker)并且使用内置的ssl证书申请功能，它使用了 letsentrypted， 会自动续签，不用担心证书过期，也不需要安装 nginx，x-ui 内置了web服务器   安装后保证 v2ray 插件的状态是 running，否则可能入站配置问题   打开面板，配置入站：protocal: vless, 监听ip: 留白, 端口：443，开启 tls，tls 配置：域名：指向你代理服务器的域名，路径：选择ssl证书申请成功的路径,一般是在 /root/cert/你的域名.cer   然后查看 v2ray 的状态   客户端     参考 https://www.v2ray.com/awesome/tools.html   windows 平台推荐使用 v2rayN   除了及时检查更新（自动把core，geo更新）外，无需修改其它配置   导入订阅地址即可  ","categories": ["network"],
        "tags": ["vpn","proxy"],
        "url": "/network/scientific-surfing/",
        "teaser": null
      },{
        "title": "Summary",
        "excerpt":"linux  权限管理     角色分为三类：owner、group、other   三类权限分别为：r(4)、w(2)、x(1)   一个文件只能有一个所有者，但可以有多个用户组   一个用户可以同时属于多个组，但只有一个主组   一个用户的权限由其所有者权限和所属组权限共同决定   文件系统     linux 将所有的硬件设备都当作文件来管理，包括硬盘、U盘、键盘、鼠标、显示器等   好处一，所有的设备都可以用同样的方式访问，而不必区分设备的类型   好处二，所有的设备都可以用同样的命令来管理，而不必记忆特定的命令   好处三，所有的设备都可以用同样的权限来管理，而不必区分设备的类型   好处四，所有的设备都可以用同样的文件系统来管理，而不必区分设备的类型   MySQL  InnoDB 存储引擎  数据存储     数据存储在数据页中，每个数据页的大小为 16KB   超出 16KB 的数据会存储在溢出页中，溢出页的大小为 16KB   每个数据页中都有一个指向溢出页的指针   索引     使用B+树作为索引结构，每个节点(数据页)的大小为 16KB   属于聚集索引，即索引和数据保存在同一颗树，数据页中的数据按照主键的顺序存储   叶子节点中存储的是数据，非叶子节点中存储的是主键   事务     事务的隔离级别            读未提交(read uncommitted)       读已提交(read committed)       可重复读(repeatable read)       串行化(serializable)           事务的并发问题            脏读(dirty read)       不可重复读(non-repeatable read)       幻读(phantom read)           事务的隔离级别和并发问题            读未提交(read uncommitted)                    脏读(dirty read)           不可重复读(non-repeatable read)           幻读(phantom read)                       读已提交(read committed)                    不可重复读(non-repeatable read)           幻读(phantom read)                       可重复读(repeatable read)                    幻读(phantom read)                       串行化(serializable)                    无并发问题                           锁机制            共享锁(shared lock)       排他锁(exclusive lock)       记录锁(record lock)       间隙锁(gap lock)       临键锁(next-key lock)           Java  JVM  内存模型(运行时数据区)，分区分代     堆            存储的数据                    存储对象实例           堆中的对象实例可以被所有线程访问           堆中的对象实例可以被所有线程共享           堆中的对象实例可以被所有线程修改                       堆是GC的主要区域                    管理方式：分代管理           分代：新生代、老年代、永久代           新生代：Eden区、Survivor区           老年代：存储生命周期较长的对象实例           永久代(也就是方法区)：存储类的信息、常量、静态变量、即时编译器编译后的代码、运行时常量池、方法的字节码、方法的访问权限、方法的参数和返回值、方法的局部变量表大小                       GC算法                    标记-清除算法           复制算法           标记-整理算法           分代收集算法                       垃圾收集器                    Serial Old收集器           Parallel Old收集器           Serial收集器           ParNew收集器           CMS收集器           G1收集器                           方法区            存储类的信息       存储常量       存储静态变量       存储即时编译器编译后的代码       存储运行时常量池       存储方法的字节码       存储方法的访问权限       存储方法的参数和返回值       存储方法的局部变量表大小           线程包含的内存            程序计数器       虚拟机栈       本地方法栈           程序计数器            用于记录当前线程执行的字节码的行号       线程私有       线程切换不会影响程序计数器的值       为了线程切换后能恢复到正确的执行位置，所以每个线程都需要一个独立的程序计数器           虚拟机栈, 包含一个或多个栈帧，调用新方法时，会创建新的栈帧，并压入到虚拟机栈的顶部            每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息       局部变量表                    存储方法的参数和局部变量           以变量槽(slot)为最小单位，一个变量槽可以存储一个32位以内的数据类型           局部变量表的大小在编译期间就已经确定，存储在方法区中的Code属性中           局部变量表的大小在运行期间不会改变           局部变量表的大小会影响方法的栈帧大小，进而影响方法的可用性                       操作数栈                    用于存储方法执行过程中的中间结果           以操作数栈帧(frame)为最小单位，一个操作数栈帧可以存储一个32位以内的数据类型           操作数栈的大小在编译期间就已经确定，存储在方法区中的Code属性中           操作数栈的大小在运行期间不会改变           操作数栈的大小会影响方法的栈帧大小，进而影响方法的可用性                       动态链接                    用于指向运行时常量池中该方法的引用           在类加载的时候，动态链接会被指向该方法在常量池中的引用                       方法出口                    用于指向方法的返回地址           方法出口的值在编译期间就已经确定，存储在方法区中的Code属性中           方法出口的值在运行期间不会改变                           加密通信  加密方式  - 对称加密     - 加密和解密使用同一个密钥     - 加密速度快     - 密钥的传输比较麻烦     - 适合对大数据进行加密 - 非对称加密         - 加密和解密使用不同的密钥     - 加密速度慢     - 密钥的传输比较方便     - 适合对小数据进行加密 - 混合加密        - 先使用非对称加密对对称加密的密钥进行加密，然后使用对称加密对数据进行加密     - 既能保证数据的安全性，又能保证加密的速度 # 哈希 ## 哈希算法在分区中的应用 - 哈希取余分区 - 一致性哈希分区: 将整个哈希空间组织成一个虚拟的圆环，将节点映射到圆环上，将数据映射到圆环上，数据会被映射到离它最近的节点上，当节点发生变化时，只会影响到它附近的数据，而不会影响到整个哈希空间, 但是会导致数据倾斜，可以使用虚拟节点解决数据倾斜的问题      - 虚拟圆环大小为 2^32, 也就是 0 ~ 2^32-1     - 对key的哈希值计算需要使用 CRC32 算法，因为它的哈希值范围是 0 ~ 2^32-1 - 带虚拟节点的一致性哈希分片  ","categories": ["idea"],
        "tags": ["linux","mysql","java","jvm","encryption","hash","redis","github","mariadb","ssh","ssl","server","cache","security"],
        "url": "/idea/summary/",
        "teaser": null
      },{
        "title": "MariaDB",
        "excerpt":"安装  服务端  sudo apt-get install mariadb-server   客户端  Ubuntu 命令行客户端  sudo apt-get install mariadb-client   Windows 客户端     MySQL Workbench   HeidiSQL   Navicat   SQLyog   Mac 客户端     Sequel Pro   配置  服务端(ip绑定和用户权限)  初始化 root 密码  sudo mysql_secure_installation  ip绑定     需要修改配置文件，使其支持远程连接，这里远程是指 server 绑定到多个网卡的 IP 地址，允许通过这些本机的网卡 IP 地址连接到 server   sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf # 修改 bind-address 为 0.0.0.0, 默认是 127.0.0.1, 即只能本地 localhost 连接 ,然后重启服务   用户权限     配置用户权限   # 登录 mysql mysql -u root -p # 选择数据库 use mysql; # 查看用户 select user,host from user;  # 创建用户，下面的 % 是指所有 IP 地址都可以连接，如果指定 IP 地址，如 '用户名'@'192.168.10.8', 也可以用通配符指定网段 '用户名'@'192.168.10.%' create user '用户名'@'%' identified by '密码';  # 授权，% 可改成具体的ip地址，'用户名'@'%' 必须存在于 user 表中，*.* 表示所有数据库，all privileges 表示所有权限 grant all privileges on *.* to '用户名'@'%';  # 查看用户权限 show grants for '用户名'@'%';  # 刷新权限 flush privileges;      移除用户权限   # 移除权限 revoke all privileges on *.* from '用户名'@'%';  # 删除用户 drop user '用户名'@'%';    拉数据  快速导出excel,效率最高的方式  # 导出csv select * from table_name into outfile '/tmp/table_name.csv' fields terminated by ',' optionally enclosed by '\"' escaped by '\"' lines terminated by '\\n'; # 使用 bash 导出 csv mysql -u your_username -p your_database_name -e \"SELECT * FROM your_table_name;\" | sed 's/\\t/\",\"/g;s/\"NULL\"/\"\"/g;s/^/\"/;s/$/\"/' &gt; /path/to/export/directory/your_table_name.csv # 然后用 zip 压缩 zip -r your_table_name.zip your_table_name.csv # 最后用 scp/ftp 拉到本地 scp your_username@your_server_ip:/path/to/your_table_name.zip /path/to/your_local_directory   ","categories": ["database"],
        "tags": ["mariadb","mysql"],
        "url": "/database/mariadb/",
        "teaser": null
      }]
