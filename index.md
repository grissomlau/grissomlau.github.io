---
layout: home
---

# Summary

<details markdown="block">
<summary>TOC</summary>

<!-- TOC -->

- [Summary](#summary)
    - [linux](#linux)
        - [权限管理](#权限管理)
        - [文件系统](#文件系统)
    - [MySQL](#mysql)
        - [InnoDB 存储引擎](#innodb-存储引擎)
            - [数据存储](#数据存储)
            - [索引](#索引)
            - [事务](#事务)
    - [Java](#java)
        - [JVM](#jvm)
            - [内存模型(运行时数据区)，分区分代](#内存模型运行时数据区分区分代)
    - [加密通信](#加密通信)
        - [加密方式](#加密方式)
    - [哈希](#哈希)
        - [哈希算法在分区中的应用](#哈希算法在分区中的应用)

<!-- /TOC -->

</details>

---


## linux
### 权限管理
- 角色分为三类：owner、group、other
- 三类权限分别为：r(4)、w(2)、x(1)
- 一个文件只能有一个所有者，但可以有多个用户组
- 一个用户可以同时属于多个组，但只有一个主组
- 一个用户的权限由其所有者权限和所属组权限共同决定

### 文件系统
- linux 将所有的硬件设备都当作文件来管理，包括硬盘、U盘、键盘、鼠标、显示器等
- 好处一，所有的设备都可以用同样的方式访问，而不必区分设备的类型
- 好处二，所有的设备都可以用同样的命令来管理，而不必记忆特定的命令
- 好处三，所有的设备都可以用同样的权限来管理，而不必区分设备的类型
- 好处四，所有的设备都可以用同样的文件系统来管理，而不必区分设备的类型

## MySQL
### InnoDB 存储引擎
#### 数据存储
- 数据存储在数据页中，每个数据页的大小为 16KB
- 超出 16KB 的数据会存储在溢出页中，溢出页的大小为 16KB
- 每个数据页中都有一个指向溢出页的指针

#### 索引
- 使用B+树作为索引结构，每个节点(数据页)的大小为 16KB
- 属于聚集索引，即索引和数据保存在同一颗树，数据页中的数据按照主键的顺序存储
- 叶子节点中存储的是数据，非叶子节点中存储的是主键

#### 事务
- 事务的隔离级别
  - 读未提交(read uncommitted)
  - 读已提交(read committed)
  - 可重复读(repeatable read)
  - 串行化(serializable)
- 事务的并发问题
    - 脏读(dirty read)
    - 不可重复读(non-repeatable read)
    - 幻读(phantom read)
- 事务的隔离级别和并发问题
    - 读未提交(read uncommitted)
        - 脏读(dirty read)
        - 不可重复读(non-repeatable read)
        - 幻读(phantom read)
    - 读已提交(read committed)
        - 不可重复读(non-repeatable read)
        - 幻读(phantom read)
    - 可重复读(repeatable read)
        - 幻读(phantom read)
    - 串行化(serializable)
        - 无并发问题
- 锁机制
    - 共享锁(shared lock)
    - 排他锁(exclusive lock)
    - 记录锁(record lock)
    - 间隙锁(gap lock)
    - 临键锁(next-key lock)

---
## Java
### JVM
#### 内存模型(运行时数据区)，分区分代
- 堆
    - 存储的数据
        - 存储对象实例
        - 堆中的对象实例可以被所有线程访问
        - 堆中的对象实例可以被所有线程共享
        - 堆中的对象实例可以被所有线程修改
    - 堆是GC的主要区域
        - 管理方式：分代管理
        - 分代：新生代、老年代、永久代
        - 新生代：Eden区、Survivor区
        - 老年代：存储生命周期较长的对象实例
        - 永久代(也就是方法区)：存储类的信息、常量、静态变量、即时编译器编译后的代码、运行时常量池、方法的字节码、方法的访问权限、方法的参数和返回值、方法的局部变量表大小
    - GC算法
        - 标记-清除算法
        - 复制算法
        - 标记-整理算法
        - 分代收集算法
    - 垃圾收集器
        - Serial Old收集器
        - Parallel Old收集器
        - Serial收集器
        - ParNew收集器
        - CMS收集器
        - G1收集器


- 方法区
    - 存储类的信息
    - 存储常量
    - 存储静态变量
    - 存储即时编译器编译后的代码
    - 存储运行时常量池
    - 存储方法的字节码
    - 存储方法的访问权限
    - 存储方法的参数和返回值
    - 存储方法的局部变量表大小
- 线程包含的内存
    - 程序计数器
    - 虚拟机栈
    - 本地方法栈
- 程序计数器
    - 用于记录当前线程执行的字节码的行号
    - 线程私有
    - 线程切换不会影响程序计数器的值
    - 为了线程切换后能恢复到正确的执行位置，所以每个线程都需要一个独立的程序计数器
- 虚拟机栈, 包含一个或多个栈帧，调用新方法时，会创建新的栈帧，并压入到虚拟机栈的顶部
    - 每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
    - 局部变量表
        - 存储方法的参数和局部变量
        - 以变量槽(slot)为最小单位，一个变量槽可以存储一个32位以内的数据类型
        - 局部变量表的大小在编译期间就已经确定，存储在方法区中的Code属性中
        - 局部变量表的大小在运行期间不会改变
        - 局部变量表的大小会影响方法的栈帧大小，进而影响方法的可用性
    - 操作数栈
        - 用于存储方法执行过程中的中间结果
        - 以操作数栈帧(frame)为最小单位，一个操作数栈帧可以存储一个32位以内的数据类型
        - 操作数栈的大小在编译期间就已经确定，存储在方法区中的Code属性中
        - 操作数栈的大小在运行期间不会改变
        - 操作数栈的大小会影响方法的栈帧大小，进而影响方法的可用性
    - 动态链接
        - 用于指向运行时常量池中该方法的引用
        - 在类加载的时候，动态链接会被指向该方法在常量池中的引用
    - 方法出口
        - 用于指向方法的返回地址
        - 方法出口的值在编译期间就已经确定，存储在方法区中的Code属性中
        - 方法出口的值在运行期间不会改变

---
## 加密通信
### 加密方式
- 对称加密
    - 加密和解密使用同一个密钥
    - 加密速度快
    - 密钥的传输比较麻烦
    - 适合对大数据进行加密
- 非对称加密    
    - 加密和解密使用不同的密钥
    - 加密速度慢
    - 密钥的传输比较方便
    - 适合对小数据进行加密
- 混合加密   
    - 先使用非对称加密对对称加密的密钥进行加密，然后使用对称加密对数据进行加密
    - 既能保证数据的安全性，又能保证加密的速度

---
## 哈希
### 哈希算法在分区中的应用
- 哈希取余分区
- 一致性哈希分区: 将整个哈希空间组织成一个虚拟的圆环，将节点映射到圆环上，将数据映射到圆环上，数据会被映射到离它最近的节点上，当节点发生变化时，只会影响到它附近的数据，而不会影响到整个哈希空间, 但是会导致数据倾斜，可以使用虚拟节点解决数据倾斜的问题 
    - 虚拟圆环大小为 2^32, 也就是 0 ~ 2^32-1
    - 对key的哈希值计算需要使用 CRC32 算法，因为它的哈希值范围是 0 ~ 2^32-1
- 带虚拟节点的一致性哈希分片